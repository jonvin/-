---
title: react的diff算法
date: 2021-01-14 15:23:58
tags:
---

前言： React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心
Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。



传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。



diff 策略

Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。

拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。



Tree Diff

Tree Diff 是两颗新旧虚拟树按照层级对应关系，把同一父节点的同一层级的节点遍历一遍，找到差异节点。

这种比较适用于DOM节点跨层级操作少的情形，这样就可以忽略不计层级带来的影响。它的分层比较，层级控制非常高效，当发现子节点不在了将会直接删除该节点以及它下面的所有子节点，也就是只需要遍历一遍。

Component Diff

React构建的应用是以组件组合而成的，以组件为单位的差异对比策略也类似。

对于类型相同的组件，可以根据VDOM树按照原来的策略继续比较Tree即可。

对于类型不同的组件，React会将整个组件内部的所有的子节点重新替换。

Element Diff

React在遇到类型相同的组件时，会继续对组件内部元素进行对比，检查内部元素的异同，这就是Element Diff。

不带key的组件，即使是相同节点，而且只是位移，还是需要删除并重写，无疑这种操作很繁琐并且低效。

在React中，可以给每个同层组件设置一个唯一的key，用来做标记。这样diff出不同的时候，只需要将节点集合进行位移即可。


总结：

Tree diff：采用分层求异的策略，将新旧两棵DOM树按照层级关系进行比较，这样只需要遍历一遍，就能搞找到那些元素需要更新。
Component diff：查看组件类型是否相同。如果类型不同，则需要更新，更新时先把旧组件删除，再创建一个新的组件插入之前删除的位置。
Element diff：通过唯一key，对元素diff进行优化。元素发生了改变，则找到需要修改的元素，有针对性进行修改。